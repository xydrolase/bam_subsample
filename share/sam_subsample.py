#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
sam_subsample.py

Author: Xin Yin <xinyin at iastate dot edu>

This tool is mainly used to generate subsample from a DNA sequencing
dataset (FASTQ file) using the read alignment results in SAM format
as guideline.

Please refer to the SAM Format Specification for more details on 
manipulation of SAM format datafiles.
    http://samtools.sourceforge.net/SAM1.pdf 

Some terminology:
    Template -- A DNA/RNA sequence part of which is sequenced on a 
    sequencer.

    Segment  -- A contiguous (sub)sequence on a template which is 
    sequenced (or assembled, but not of our interest).

The main goal is to select reads that map back to a selected region of 
the genome, so that a smaller dataset can be generated with comparable 
coverage to the full dataset. 
"""

from argparse import ArgumentParser
from itertools import izip, cycle
from math import floor

from read_filter import Read

import sys
import re

complements = {'A':'T', 'T': 'A', 'G': 'C', 'C': 'G', 'N': 'N'}
# map cigar operators to how they would affect length of the mapped
# segment.
cigar_op_map = {'M': 1, 'I': 0, 'D': -1, 'S': 1, 'H': 0}

# column definitions
COL_QNAME, COL_FLAG, COL_RNAME, COL_POS, COL_MAPQ, COL_CIGAR, \
        COL_RNEXT, COL_PNEXT, COL_TLEN, COL_SEQ, COL_QUAL = range(11)

# mapping flags
FLAG_UNMAPPED = 0x4
FLAG_REVCOMP = 0x10
FLAG_1ST_READ = 0x40
FLAG_2ND_READ = 0x80
FLAG_SECONDARY = 0x100

def parse_int(s):
    num = int(re.compile('(\d+)').search(s).group(1))
    suffix = s[-1]
    if suffix in ('k', 'K'):
        num *= 1000
    elif suffix in ('m', 'M'):
        num *= 1e6

    return int(num)

def compute_segment_length(c_op, c_num):
    return sum([x*y for x, y in zip(c_num, 
        [cigar_op_map.get(op, 0) for op in c_op])])

def compute_base_offset(c_op, c_num):
    if c_op[0] == 'S':
        return c_num[0]

    return 0

def main():
    # reads to be extracted later
    accession_id = None
    seq_errors = []
    error_loci = []
    paired_reads = {}

    parser = ArgumentParser(
        description="Genome sequence guided FASTQ file subsampler.")
    parser.add_argument("--start", type=str, dest="start",
            help="Starting position of the selected genome region.")
    parser.add_argument("--end", type=str, dest="end",
            help="Ending position of the selected genome region.")
    parser.add_argument("-Q", dest="output_qscore", action="store_true",
            default=False, 
            help="Enable output of quality scores in error file.")
    parser.add_argument("--prefix", dest="prefix", required=True,
            help="Prefix for output files.")
    parser.add_argument("-C", "--skip-clipping", dest="skip_clipping",
            action="store_true", default=False,
            help="Skip all the reads with soft/hard clippings.")
    parser.add_argument("-l", "--length", metavar="L", dest="length",
            type=int, help="Cap the maximum read length to L.")
    parser.add_argument("--discard-N", dest="discard_N", 
            action="store_true", default=False,
            help="Skip all the reads with N base(s).")
    parser.add_argument("--read-id-first", dest="read_id_first",
            action="store_true", default=False)
    parser.add_argument("--ref-name", dest="ref_name",
            help="Name of the reference sequence, available when multiple"
            " sequences are indexed.")
    parser.add_argument("--pairs-only", dest="pairs_only", 
            action="store_true", default=False,
            help="Discard both paired-end reads if any of the two is "
            "discarded.")
    parser.add_argument("--fwd-strand-only", dest="fwd_strand_only",
            action="store_true", default=False,
            help="Discard all reads on the reverse strand (relative to the"
            "reference genome).")
    parser.add_argument("--expand-read-id", dest="expand_read_id",
            action="store_true", default=False,
            help="For SAM file generated by Novoalign, expand read id to "
            "include matepair information.")
    parser.add_argument("--error-loci", dest="output_error_loci",
            action="store_true", default=False,
            help="Output error loci in selected genomic region to PREFIX.eli."
            )
    
    parser.add_argument("sam_file", type=file,
            help="Alignment results in SAM format.")

    args = parser.parse_args()

    if args.fwd_strand_only and args.pairs_only:
        print >>sys.stderr, \
                "ERROR: --fwd-strand-only and --pairs-only are mutually "\
                "exclusive."
        sys.exit(1)

    if args.start is not None:
        args.start = parse_int(args.start)
    else:
        args.start = 0

    if args.end is not None:
        args.end = parse_int(args.end)
    else:
        args.end = 2**32

    print >>sys.stderr, \
            'Selected region in genome: {0}..{1}'.format(
                    args.start, args.end)

    fd_fastq = open('{0}.fastq'.format(args.prefix), 'w+')
    #fd_error = open('{0}.error'.format(args.prefix), 'w+')
    #fd_cov = open("{0}.cov".format(args.prefix), "w+")

    fd_eli = None
    if args.output_error_loci:
        fd_eli = open("{0}.eli".format(args.prefix), "w+")

    regex_base = re.compile(r'([ACGT])')
    regex_cigar = re.compile(r'[MIDNSH]')
    regex_clip = re.compile(r'\d+[SH]')
    set_bases = set(['A', 'C', 'G', 'T'])

    prev_read_id = None

    for id, line in enumerate(args.sam_file):
        # skip headers
        if line.startswith('@'):
            continue

        if id % 100000 == 0:
            print >>sys.stderr, id, "lines processed."

        segments = line.strip().split('\t')

        align_flag = int(segments[COL_FLAG])
        map_qual = int(segments[COL_MAPQ])
        map_pos = int(segments[COL_POS])
        cigar = segments[COL_CIGAR]

        # process errors
        read_id = segments[COL_QNAME]
        read_seq = segments[COL_SEQ]
        read_qscore = segments[COL_QUAL]

        if args.expand_read_id:
            if align_flag & FLAG_1ST_READ:
                read_id = '%s/1' % read_id
            elif align_flag & FLAG_2ND_READ:
                read_id = '%s/2' % read_id

        # skip if the reference doesn't match what user specified.
        if args.ref_name and segments[COL_RNAME] != args.ref_name:
            continue

        # skip all ambiguously mapped/unmapped reads.
        if align_flag & FLAG_UNMAPPED or map_qual == 0 or cigar == '*':
            continue

        # check if current read maps to the genomic region of interest
        if map_pos < args.start or map_pos > args.end:
            continue

        # process cigar
        cigar_ops = re.findall(regex_cigar, cigar)
        cigar_nums = [int(x) for x in re.split(regex_cigar, cigar) if x]

        # skip read with soft/hard clippings if user opted so.
        if args.skip_clipping and regex_clip.search(cigar): 
            continue

        # the true segment length in reference genome
        segment_len = compute_segment_length(cigar_ops, cigar_nums)

        # skip all the reads with insertions/deletions and hard clippings.
        if segment_len != len(read_seq):
            continue

        if args.discard_N and read_seq.find('N') != -1:
            continue

        if args.fwd_strand_only and align_flag & FLAG_REVCOMP:
            continue

        if align_flag & FLAG_REVCOMP:
            r_read_qscore = read_qscore[::-1]
            r_read_seq = ''.join([complements[x] for x in read_seq][::-1])
        else:
            r_read_qscore = read_qscore
            r_read_seq = read_seq

        if args.pairs_only:
            read_pair_id = (read_id, 1 if align_flag & FLAG_1ST_READ else 2)
            paired_reads[read_pair_id] = Read(
                    '/'.join(map(str, read_pair_id)),
                    r_read_seq, r_read_qscore)
            twin_id = (read_id, 3 - read_pair_id[1])
            if twin_id in paired_reads:
                if read_pair_id < twin_id:
                    fd_fastq.write(str(paired_reads[read_pair_id]))
                    fd_fastq.write(str(paired_reads[twin_id]))
                else:
                    fd_fastq.write(str(paired_reads[twin_id]))
                    fd_fastq.write(str(paired_reads[read_pair_id]))

                del paired_reads[twin_id]
                del paired_reads[read_pair_id]
        else:
            r = Read(read_id, r_read_seq, r_read_qscore)
            fd_fastq.write(str(r))

        # record mapping position and segment length.
        #fd_cov.write("{0} {1}\n".format(map_pos, segment_len))

        if not args.output_error_loci:
            continue

        md_tag = [seg.split(':')[2] for seg in segments if seg.startswith('MD')][0]
        if md_tag.find('^') != -1:
            continue

        md_record = re.split(regex_base, md_tag)

        if not accession_id:
            accession_id = read_id[:read_id.find('.')]

        # find the the base offset to compute the actual error loci
        # for reads with soft clipping.
        read_pos = compute_base_offset(cigar_ops, cigar_nums)

        #shift = 0
        #if segment_len > args.length:
        #    shift = segment_len - args.length

        for md in md_record: 
            if md.isdigit():
                read_pos += int(md)
            elif md in set_bases:
                if args.output_error_loci:
                    error_loci.append(
                            (
                                map_pos + read_pos, 
                                (align_flag & FLAG_REVCOMP) > 0)
                            )
                    
                if align_flag & FLAG_REVCOMP:
                    seq_errors.append((read_id, segment_len,
                        segment_len-read_pos,
                        complements[md], 
                        complements[read_seq[read_pos]],
                        ' '.join(('', read_qscore[read_pos])) if \
                                args.output_qscore else ''
                        ))
                    #fd_error.write('{0} {1} {2} {3}{4}\n'.format(
                    #    read_id, segment_len-read_pos, # 1-based coordinate
                    #    complements[md], # compute the complementary base
                    #    complements[read_seq[read_pos]],
                    #    ' '.join(('', read_qscore[read_pos])) if \
                    #            args.output_qscore else ''
                    #    ))
                else:
                    seq_errors.append((read_id, segment_len,
                        read_pos+1,
                        md, read_seq[read_pos], 
                        ' '.join(('', read_qscore[read_pos])) if \
                                args.output_qscore else ''))
                    #fd_error.write('{0} {1} {2} {3}{4}\n'.format(
                    #    read_id, read_pos+1,
                    #    md, read_seq[read_pos],
                    #    ))

                # each mismatch record also accounts for 1 base 
                read_pos += 1

    if args.output_error_loci:
        fd_eli.write("\n".join(
            ("{0} {1}".format(loci, rcf) for loci, rcf in error_loci)))

    fd_fastq.close()
    if fd_eli:
        fd_eli.close()

if __name__ == "__main__":
    main()
